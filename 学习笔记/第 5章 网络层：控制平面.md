# 第 5 章 网络层：控制平面
# 导论
- 传统方式：每-路由器(Per-router)控制平面
  - 在每一个路由器中的单独路由器算法元件，在控制平面进行交互
- SDN 方式：逻辑上集中的控制平面
  - 一个不同的（通常是远程的）控制器与本地控制代理（CAs）交互
# 路由选择算法
- **路由:** 按照某种指标(传输延迟,所经过的站点数目等)找到一条从源节点到目标节点的较好路径。
  - **较好路径:** 按照某种指标较小的路径
  - **指标:** 站数, 延迟,费用,队列长度等, 或者是一些单纯指标的加权平均
  - 采用什么样的指标,表示网络使用者希望网络在什么方面表现突出,什么指标网络使用者比较重视
- 网络到网络的路由= 路由器-路由器之间路由
  - 网络对应的路由器到其他网络对应的路由器的路由
  - 在一个网络中：路由器-主机之间的通信，链路层解决
  - 到了这个路由器就是到了这个网络
- **路由的输入：拓扑、边的代价、源节点**
- **输出的输出：源节点的汇集树**
- 最优化原则(optimality principle)
  - 汇集树(sink tree)
  - 此节点到所有其它节点的最优路径形成的树
  - 路由选择算法就是为所有路由器找到并使用汇集树
- 路由的原则
  - **正确性(correctness)**
  - **简单性(simplicity)**
  - **健壮性(robustness)**
  - **稳定性(stability)**
  - **公平性(fairness)**
  - **最优性(optimality)**
## link state（Dijkstra 算法）
- 链路状态路由选择
- 全局的静态的
### 工作过程
1.  配置过程
    - 各点通过各种渠道获得整个网络拓扑, 网络中所有链路代价等信息（这部分和算法没关系，属于协议和实现）→ 泛洪
    - 使用 LS 路由算法,计算本站点到其它站点的最优路径(汇集树),得到路由表
    - 按照此路由表转发分组(datagram 方式)
      - 严格意义上说不是路由的一个步骤
      - 分发到输入端口的网络层
2.  工作过程
    1.  发现相邻节点,获知对方网络地址
        1.  一个路由器上电之后,向所有线路发送 HELLO 分组
        2.  其它路由器收到 HELLO 分组,回送应答,在应答分组中,告知自己的名字(全局唯一)
        3.  在 LAN 中,通过广播 HELLO 分组,获得其它路由器的信息,可以认为引入一个人工节点
    2.  测量到相邻节点的代价(延迟,开销)
        1.  实测法,发送一个分组要求对方立即响应
        2.  回送一个 ECHO 分组
        3.  通过测量时间可以估算出延迟情况
    3.  组装一个 LS 分组,描述它到相邻节点的代价情况
        1.  发送者名称
        2.  序号,年龄
        3.  列表: 给出它相邻节点,和它到相邻节点的延迟
    4.  将分组通过扩散的方法发到所有其它路由器**以上 4 步让每个路由器获得拓扑和边代价**
        1.  顺序号:用于控制无穷的扩散,每个路由器都记录(源路由器,顺序号),发现重复的或老的就不扩散
            1.  循环使用问题
            2.  路由器崩溃之后序号从 0 开始
            3.  序号出现错误
        2.  解决问题的办法:年龄字段(age)
          1.  生成一个分组时,年龄字段不为 0
          2.  每个一个时间段,AGE 字段减 1
          3.  AGE 字段为 0 的分组将被抛
        3.  关于扩散分组的数据结构
            1.  Source :从哪个节点收到 LS 分组
            2.  Seq,Age:序号,年龄
            3.  Send flags:发送标记,必须向指定的哪些相邻站点转发 LS 分组
            4.  ACK flags:本站点必须向哪些相邻站点发送应答
            5.  DATA:来自 source 站点的 LS 分组
    5.  通过 Dijkstra 算法找出最短路径（这才是路由算法）
        1.  路由器获得各站点 LS 分组和整个网络的拓扑
        2.  通过 Dijkstra 算法计算出到其它各路由器的最短路径(汇集树)
        3.  将计算结果安装到路由表中
    6.  每个节点独立算出来到其他节点（路由器=网络）的最短路径
    7.  迭代算法：第 k 步能够知道本节点到 k 个其他节点的最短路径
## distance vector（Bellman-Ford）
- 距离矢量路由选择
- 动态路由算法之一
- 距离矢量路由选择的基本思想
  - 各路由器维护一张路由表,结构如图(其它代价)
  - 各路由器与相邻路由器交换路由表
  - 根据获得的路由信息,更新路由表
- 代价及相邻节点间代价的获得
  - 跳数(hops), 延迟(delay),队列长度
  - 相邻节点间代价的获得：通过实测
- 路由信息的更新
  - 根据实测 得到本节点 A 到相邻站点的代价（如:延迟）
  - 根据各相邻站点声称它们到目标站点 B 的代价
  - 计算出本站点 A 经过各相邻站点到目标站点 B 的代价
  - **找到一个最小的代价，和相应的下一个节点 Z，到达节点 B 经过此节点 Z，并且代价为 A-Z-B 的代价**
  - 其它所有的目标节点一个计算法
### 距离矢量算法
​	$d_x(y) = min (c(x,v) + d_v(y))$
- $c(x,v)$ →x 到邻居 v 的代价
- $d_v(y)$ → 从邻居 v 到目标 y 的代价
- $ min $→ 取所有 x 的邻居取最小的 v
- 核心思路
  - 每个节点都将自己的距离矢量估计值传送给邻居，定时或者
    DV 有变化时，让对方去算
  - 当 x 从邻居收到 DV 时，自己运算，更新它自己的距离矢量
  - $D_x(y)$估计值最终收敛于实际的最小代价值$d_x(y)$
    **特点**
- **异步式,迭代**: 每次本地迭代被以下事件触发:
  - 本地链路代价变化了
  - 从邻居来了 DV 的更新消息
- **分布式**
  - 每个节点只是在自己的 DV 改变之后向邻居通告
  - 然后邻居们在有必要的时候通知他们的邻居
    **缺点**
- **DV 的无穷计算问题**
  - 好消息传的快 坏消息传的慢
    ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_fyPnOtbpnq.png)
    ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_oHbZF5S9nc.png)
    **优化**
- 水平分裂(split horizon)算法 → 向给自己权威距离的邻居发布一个 INF 距离其他邻居照常发送
  - 一种对无穷计算问题的解决办法
- 但对于环的问题仍然没有解决
## LS 和 DV 算法的比较
- **消息复杂度（DV 胜出）**
  - LS: 有 n 节点, E 条链路,发送报文 O(nE)个
    - 局部的路由信息；全局传播
  - DV: 只和邻居交换信息
    - 全局的路由信息，局部传播
- 收敛时间（LS 胜出）
  - LS: O(n2) 算法
    - 有可能震荡
  - DV: 收敛较慢
    - 可能存在路由环路
    - count-to-infinity 问题
- 健壮性: 路由器故障会发生什么（LS 胜出）
  - LS:
    - 节点会通告不正确的链路代价
    - 每个节点只计算自己的路由表
    - 错误信息影响较小，局部，路由较健壮
  - DV:
    - DV 节点可能通告对全网所有节点的不正确路径代价
      - 距离矢量
    - 每一个节点的路由表可能被其它节点使用
      - 错误可以扩散到全网
# 自治系统的内部路由选择
## RIP ( Routing Information Protocol)
- Distance vector 算法
  - 距离矢量:每条链路 cost=1，# of hops (max = 15 hops) 跳数
  - DV 每隔 30 秒和邻居交换 DV，通告
  - 每个通告包括：最多 25 个目标子网
    **RIP 通告（advertisements）**
- DV: 在邻居之间每 30 秒交换通告报文
  - 定期，而且在改变路由的时候发送通告报文
  - 在对方的请求下可以发送通告报文
- 每一个通告: 至多 AS 内部的 25 个目标网络的 DV
  - 目标网络+跳数
    **RIP: 链路失效和恢复**
- 如果 180 秒没有收到通告信息-->邻居或者链路失效
- 发现经过这个邻居的路由已失效
- 新的通告报文会传递给邻居
- 邻居因此发出新的通告 (如果路由变化的话)
- 链路失效快速(?)地在整网中传输
- 使用毒性逆转（poison reverse）阻止 ping-pong 回路 (不可达的距离：跳数无限 = 16 段)
  **RIP 进程处理**
- RIP 以应用进程的方式实现：route-d (daemon)
- 通告报文通过 UDP 报文传送，周期性重复
- 网络层的协议使用了传输层的服务，以应用层实体的方式实现
## OSPF (Open Shortest Path First)
- 使用 LS 算法
  - LS 分组在网络中（一个 AS 内部）分发
  - 全局网络拓扑、代价在每一个节点中都保持
  - 路由计算采用 Dijkstra 算法
- OSPF 通告信息中携带：每一个邻居路由器一个表项
- 通告信息会传遍 AS 全部（通过泛洪）
  - 在 IP 数据报上直接传送 OSPF 报文 (而不是通过 UDP 和 TCP)
    **OSPF “高级” 特性(在 RIP 中的没有的)**
- 安全: 所有的 OSPF 报文都是经过认证的 (防止恶意的攻击)
- 允许有多个代价相同的路径存在 (在 RIP 协议中只有一个)
- 对于每一个链路，对于不同的 TOS 有多重代价矩阵
  - 例如：卫星链路代价对于尽力而为的服务代价设置比较低，对实时服务代价设置的比较高
  - 支持按照不同的代价计算最优路径，如：按照时间和延迟分别计算最优路径
- 对单播和多播的集成支持:
  - Multicast OSPF (MOSPF) 使用相同的拓扑数据库，就像在 OSPF 中一样
- 在大型网络中支持层次性 OSPF
  **层次性的 OSPF 路由**
- 2 个级别的层次性: 本地, 骨干
  - 链路状态通告仅仅在本地区域 Area 范围内进行
  - 每一个节点拥有本地区域的拓扑信息；
    - 关于其他区域，知道去它的方向，通过区域边界路由器（最短路径）
- 区域边界路由器: “汇总（聚集）”到自己区域内网络的距离, 向其它区域边界路由器通告.
- 骨干路由器: 仅仅在骨干区域内，运行 OSPF 路由
- 边界路由器: 连接其它的 AS’s.
# ISP 路由选择 BGP 协议
## 层次路由
- 一个平面的路由
  - 一个网络中的所有路由器的地位一样
  - 通过 LS, DV，或者其他路由算法，所有路由器都要知道其他所有路由器（子网）如何走
  - 所有路由器在一个平面
    **平面路由的问题**
  - 规模巨大的网络中，路由信息的存储、传输和计算代价巨大
    - DV: 距离矢量很大，且不能够收敛
    - LS：几百万个节点的 LS 分组的泛洪传输，存储以及最短路径算法的计算
  - 管理问题
    - 不同的网络所有者希望按照自己的方式管理网络
    - 希望对外隐藏自己网络的细节
    - 当然，还希望和其它网络互联
      **层次路由**
- 层次路由：将互联网分成一个个 AS(路由器区域)
  - 某个区域内的路由器集合，自治系统“autonomous systems”
  - 一个 AS 用 AS Number（ASN)唯一标示。
  - 一个 ISP 可能包括 1 个或者多个 AS
- 路由变成了: 2 个层次路由
  - AS 内部路由：在同一个 AS 内路由器运行相同的路由协议
  - “intra-AS” routing
    protocol：内部网关协议
  - 不同的 AS 可能运行着不同的内部网关协议
  - 能够解决规模和管理问题 如：RIP,OSPF,IGRP
  - 网关路由器：AS 边缘路由器，可以连接到其他 AS
- AS 间运行 AS 间路由协议
  - “inter-AS” routing protocol：外部网关协议
  - 解决 AS 之间的路由问题，完成 AS 之间的互联互通
    **层次路由优点**
- 解决了规模问题
  - 内部网关协议解决：AS 内部数量有限的路由器相互到达的问题, AS 内部规模可控
    - 如 AS 节点太多，可分割 AS，使
      得 AS 内部的节点数量有限
  - AS 之间的路由的规模问题
    - 增加一个 AS，对于 AS 之间的路由从总体上来说，只是增加了一个节点=子网（每个 AS 可以用一个点来表示）
    - 对于其他 AS 来说只是增加了一个表项，就是这个新增的 AS 如何走的问题
    - 扩展性强：规模增大，性能不会减得太多
- 解决了管理问题
  - 各个 AS 可以运行不同的内部网关协议
  - 可以使自己网络的细节不向外透露
## BGP
- BGP (Border Gateway Protocol): 自治区域间路由协议“事实上的”标准
  - “将互联网各个 AS**粘在一起的胶水**”
- BGP 提供给每个 AS 以以下方法：
  - eBGP: 从相邻的 ASes 那里获得子网可达信息
  - iBGP: 将获得的子网可达信息传遍到 AS 内部的所有路由器
  - 根据子网可达信息和策略来决定到达子网的**“好”路径**
- 允许子网向互联网其他网络通告“我在这里”
- 基于距离矢量算法（路径矢量）
  - 不仅仅是距离矢量，还包括到达各个目标网络的详细路径（AS 序号的列表）能够避免简单 DV 算法的路由环路问题
    ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_fFLZBBvWQL.png)
### BGP 基础
- BGP 会话: 2 个 BGP 路由器(“peers”)在一个**半永久的 TCP**连接上交换 BGP 报文
  - 通告向不同目标子网前缀的“路径”（BGP 是一个“路径矢量”协议）
- 当 AS3 网关路由器 3a 向 AS2 的网关路由器 2c 通告路径： AS3,X
  - 3a 参与 AS 内路由运算，知道本 AS 所有子网 X 信息
  - 语义上：AS3 向 AS2 承诺，它可以向子网 X 转发数据报
  - 3a 是 2c 关于 X 的下一跳（next hop）
    ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_6D-TIKo4xU.png)
    **路径的属性 BGP 路由**
- 当通告一个子网前缀时，通告包括 BGP 属性
  - prefix + attributes = “route”
- 2 个重要的属性:
  - AS-PATH: 前缀的通告所经过的 AS 列表: AS 67 AS 17
    - 检测环路；多路径选择
    - 在向其它 AS 转发时，需要将自己的 AS 号加在路径上
  - NEXT-HOP: 从当前 AS 到下一跳 AS 有多个链路，在 NETX-HOP 属性中，告诉对方通过那个 I 转发
  - 其它属性：路由偏好指标，如何被插入的属性
- 基于策略的路由
  - 当一个网关路由器接收到了一个路由通告, 使用输入策略来接受或过滤（accept/decline.）
    - 过滤原因例 1：不想经过某个 AS，转发某些前缀的分组
    - 过滤原因例 2：已经有了一条往某前缀的偏好路径
  - 策略也决定了是否向它别的邻居通告收到的这个路由信息
### BGP 路径通告
![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_Ju8J1fubwa.png)
- 路由器 AS2.2c 从 AS3.3a 接收到的 AS3,X 路由通告 (通过 )
- 基于 AS2 的输入策略，AS2.2c 决定接收 AS3,X 的通告，而且通过 iBGP）向 AS2 的所有路由器进行通告
- 基于 AS2 的策略，AS2 路由器 2a 通过 eBGP 向 AS1.1c 路由器通告 AS2,AS3,X 路由信息
  - 路径上加上了 AS2 自己作为 AS 序列的一跳
    ![](image/image_UrvUhXXbXe.png)
    网关路由器可能获取有关一个子网 X 的多条路径，从多个 eBGP 会话上：
- AS1 网关路由器 1c 从 2a 学习到路径：AS2,AS3,X
- AS1 网关路由器 1c 从 3a 处学习到路径 AS3,X
- 基于策略，AS1 路由器 1c 选择了路径：AS3,X，而且通过 iBGP 告诉所有 AS1 内部的路由器
## BGP 报文
- 使用 TCP 协议交换 BGP 报文
- BGP 报文:
  - **OPEN: **打开 TCP 连接，认证发送方
  - **UPDATE:** 通告新路径 (或者撤销原路径)
  - **KEEPALIVE：** 在没有更新时保持连接，也用于对 OPEN 请求确认
  - **NOTIFICATION:** 报告以前消息的错误，也用来关闭连接
## BGP, OSPF, 转发表表项
![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_aKBxFMGGMN.png)
![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_dwANTbmVJV.png)
## BGP 路径选择
- 路由器可能获得一个网络前缀的多个路径，路由器必须进行路径的选择，路由选择可以基于：
  - 本地偏好值属性: 偏好策略决定
  - 最短 AS-PATH ：AS 的跳数
  - 最近的 NEXT-HOP 路由器:热土豆路由
  - 附加的判据：使用 BGP 标示
- 一个前缀对应着多种路径，采用消除规则直到留下一条路径
- 热土豆路由
  ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_fn6Lb79Drg.png)
  - 2d 通过 iBGP 获知，它可以通过 2a 或者 2c 到达 X
  - 热土豆策略：选择具备最小内部区域代价的网关作为往 X 的出口（如：2d 选择 2a，即使往 X 可能有比较多的 AS 跳数）：不要操心域间的代价！
- BGP: 通过路径通告执行策略
  ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_AL7A1ZhTRO.png)
  假设一个 ISP 只想 路由流量 到/去往它的客户网络 (不想承载其他 ISPs 之间的流量，即不通告：不是去往我的客户，也不是来自我的客户)
  - A 向 B 和 C 通告路径 Aw
  - B 选择不向 C 通告 BAw：
    - B 从 CBAw 的路由上无法获得收益，因为 C,A,w 都不是 B 的客户
    - C 从而无法获知 CBAw 路径的存在：每个 ISP 感知到的网络和真实不一致
  - C 可能会通过 CAw (而不是使用 B)最终路由到 w
    ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_0QASersr5I.png)
    假设一个 ISP 只想 路由流量 到/去往它的客户网络 (不想承载其他 ISPs 之间的流量，即不通告：不是去往我的客户，也不是来自我的客户)
  - A,B,C 是 提供商网络
  - X,W,Y 是桩网络（stub networks）或者叫端网络
  - X 是双重接入的，多宿桩网络，接入了 2 个网络
  - 策略强制让 X
    - X 不想路由 从 B 通过 X 到 C 的 分组
    - 因而 X 就不通告给 B，它实际上可以路由到 C
## 为什么内部网关协议和外部网关协议如此不同
- 策略:
  - Inter-AS: 管理员需要控制通信路径，谁在使用它的网络进行数据传输；
  - Intra-AS: 一个管理者，所以无需策略; → AS 内部的各子网的主机尽可能地利用资源进行快速路由
- 规模:
  - AS 间路由必须考虑规模问题，以便支持全网的数据转发
  - AS 内部路由规模不是一个大的问题
    - 如果 AS 太大，可将此 AS 分成小的 AS；规模可控
    - AS 之间只不过多了一个点而已
    - 或者 AS 内部路由支持层次性，层次性路由节约了表空间, 降低了更新的数据流量
- 性能:
  - Intra-AS: 关注性能
  - Inter-AS: 策略可能比性能更重要
# SDN 控制平面
## 特点
- 通用“ flowbased” 基于流的匹配+行动(e.g., OpenFlow)
- 控制平面和数据平面的分离
- 控制平面功能在数据交换设备之外实现
- 可编程控制在控制器之上以网络应用形式实现各种网络功能
## 架构
1.  数据平面交换机
    - 快速，简单，商业化交换设备采用硬件实现通用转发功能
    - 流表被控制器计算和安装
    - 基于南向 API（例如 OpenFlow），SDN 控制器访问基于流的交换机
      - 定义了哪些可以被控制哪些不能
    - 也定义了和控制器的协议 (e.g., OpenFlow)
2.  SDN 控制器(网络 OS):
    - 维护网络状态信息
    - 通过上面的北向 API 和网络控制应用交互
    - 通过下面的南向 API 和网络交换机交互
    - 逻辑上集中，但是在实现上通常由于性能、可扩展性、容错性以及鲁棒性采用分布式方法实现
3.  网络控制应用:
    - 控制的大脑： 采用下层提供的服务（SDN 控制器提供的 API)，实现网络功能
      - 路由器 交换机
      - 接入控制 防火墙
      - 负载均衡
    - 非绑定：可以被第三方提供，与控制器厂商以通常上不同，与分组交换机厂商也可以不同
## 面临的挑战
- 强化控制平面：可信、可靠、性能可扩展性、安全的分布式系统
  - 对于失效的鲁棒性： 利用为控制平面可靠分布式系统的强大理论
  - 可信任，安全：从开始就进行铸造
- 网络、协议满足特殊任务的需求
  - e.g., 实时性，超高可靠性、超高安全性
- 互联网络范围内的扩展性
  - 而不是仅仅在一个 AS 的内部部署，全网部署
# ICMP 控制报文协议
## ICMP: Internet Control Message Protocol
- 由主机、路由器、网关用于传达网络层控制信息
  - 错误报告：主机不可到达、网络、端口、协议
  - Echo 请求和回复（ping）
- ICMP 处在网络层，但是是在 IP 协议的上面
  - ICMP 消息由 IP 数据报承载
- ICMP 报文:
  - 类型
  - 编码
  - 加上 IP 数据报的头 8B
    - 第一个导致该 ICMP 报文的 IP 数据报
## Traceroute and ICMP
- 源主机发送一系列 UDP
  段给目标主机
  - 第一个：TTL =1
  - 第二个： TTL=2, etc
  - 一个不可达的端口号
- 当 nth 数据报到达 nth 路由器
  - 路由器抛弃数据报
  - 然后发送一个给源的 ICMP 报文 (type 11, code 0)
  - 报文包括了路由器的名字和 IP 地址
- 当 ICMP 报文到达，源端计算 RTT
- 对于一个 nTraceroute 做 3 次
- 停止的判据
- UDP 段最终到达目标主机
- 目标返回给源主机 ICMP “端口不可达”报文 (type 3, code 3)
- 当源主机获得这个报文时，停止
# 网络管理与 SNMP
暂无
