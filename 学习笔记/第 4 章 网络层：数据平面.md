# 第 4 章 网络层：数据平面
# 网络层概念
## 网络层服务
*   在发送主机和接收主机对之间传送段（segment）
*   在发送端将段封装到数据报中
*   在接收端，将段上交给传输层实体
*   网络层协议存在于每一个主机和路由器
*   路由器检查每一个经过它的IP数据报的头部
### 关键功能
*   转发
    *   将分组从路由器的输入接口转发到合适的输出接口
*   路由
    *   使用路由算法来决定分组从发送主机到目标接收主机的路径
    *   路由选择算法
    *   路由选择协议
## 数据平面与控制平面
### 数据平面
*   本地，每个路由器功能
*   决定从路由器输入端口到达的分组如何转发到输出端口
*   转发功能：
    *   传统方式：基于目标地址+转发表（分布的，机械的，难扩展）
    *   SDN方式：基于多个字段+流表（集中的，可编程的）
### 控制平面
*   网络范围内的逻辑
*   决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间的端到端路径
*   2个控制平面方法:
    *   传统的路由算法: 在路由器中被实现
    *   software-defined networking (SDN): 在远程的服务器中实现
### 传统方式
*   每-路由器(Per-router)控制平面
    *   在每一个路由器中的单独路由器算法元件，在控制平面进行交互
    ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_gZFZuKmzpx.png)
*   路由和转发的相互作
    ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_8OCl-0kJ-W.png)
### SDN方式
*   逻辑集中的控制平面
    *   一个不同的（通常是远程的）控制器与本地控制代理（CAs）交互
    ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_sI3KfWRx7W.png)
## 网络服务模型
*   从发送方主机到接收方主机传输数据报的“通道”，网络提供什么样的服务模型？
    *   对于单个数据报的服务:
        *   可靠传送
        *   延迟保证，如：少于40ms的延迟
    *   对于数据报流的服务:
        *   保序数据报传送
        *   保证流的最小带宽
        *   分组之间的延迟差
*   连接的建立
    *   在某些网络架构中是第三个重要的功能
    *   在分组传输之前，在两个主机之间，在通过一些路由器所构成的路径上建立一个网络层连接
        *   涉及到路由器
    *   网络层和传输层连接服务区别:
        *   网络层: 在2个主机之间，涉及到路径上的一些路由器
        *   传输层: 在2个进程之间，很可能只体现在端系统上(TCP连接)
# 路由器
## 路由器结构
*   高层面(非常简化的)通用路由器体系架构
![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_SI9lkTwpSL.png)
*   路由：运行路由选择算法／协议 (RIP, OSPF, BGP)-生成路由表
*   转发：从输入到输出链路交换数据报-根据路由表进行分组的转发
### 输入端口
![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_ZJ7bfdOJ6t.png)
*   分布式交换：
    *   根据数据报头部的信息如：目的地址，在输入端口内存中的转发表中查找合适的输出端口（匹配+行动）
    *   基于目标的转发：仅仅依赖于IP数据报的目标IP地址（传统方法）
    *   通用转发：基于头部字段的任意集合进行转发
*   输入端口缓存
    *   当交换机构的速率小于输入端口的汇聚速率时 → 在输入端口可能要排队
    *   排队延迟以及由于输入缓存溢出造成丢失!
    *   Head-of-the-Line (HOL) blocking: 排在队头的数据报阻止了队列中其他数据报向前移动
        ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_B89knkcXZS.png)
### 交换结构
*   将分组从输入缓冲区传输到合适的输出端口
*   交换速率：分组可以按照该速率从输入传输到输出
    *   运行速度经常是输入/输出链路速率的若干倍
    *   N 个输入端口：交换机构的交换速度是输入线路速度的N倍比较理想，才不会成为瓶颈
    ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_tNiLqF46fv.png)
1.  memory
    *   在CPU直接控制下的交换，采用传统的计算机
    *   分组被拷贝到系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口
    *   转发速率被内存的带宽限制 (数据报通过BUS两遍)
    *   一次只能转发一个分组
2.  bus
    *   数据报通过共享总线，从输入端口转发到输出端口
    *   总线竞争: 交换速度受限于总线带宽
    *   1次处理一个分组
    *   对于接入或企业级路由器，速度足够（但不适合区域或骨干网络）
3.  crossbar
    1.  同时并发转发多个分组，克服总线带宽限制
    2.  Banyan（榕树）网络，crossbar(纵横)和其它的互联网络被开发，将多个处理器连接成多处理器
    3.  当分组从端口A到达，转给端口Y；控制器短接相应的两个总线
    4.  高级设计：将数据报分片为固定长度的信元，通过交换网络交换
    5.  Cisco12000：以60Gbps的交换速率通过互联网络
### 输出端口
![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_qAfQadZxIw.png)
*   数据报（分组）可能会被丢弃，由于拥塞，缓冲区没有空间
*   当数据报从交换机构的到达速度比传输速率快就需要输出端口缓存
*   由调度规则选择排队的数据报进行传输
*   缓存大小：$\frac {RTT \times C}  {\sqrt N}$(平均缓存大小=典型的RTT（例如：250ms）倍于链路容量C)
### 调度机制
*   调度: 选择下一个要通过链路传输的分组
1.  FIFO (first in first out) scheduling: 按照分组到来的次序发送
    *   丢弃策略: 如果分组到达一个满的队列，哪个分组将会被抛弃?
        *   tail drop: 丢弃刚到达的分组
        *   priority: 根据优先权丢失/移除分组
        *   random: 随机地丢弃/移除
2.  优先权调度：发送最高优先权的分组
    *   多类，不同类别有不同的优先权
        *   类别可能依赖于标记或者其他的头部字段
        *   先传高优先级的队列中的分组，除非没有
3.  Round Robin (RR) scheduling
    *   循环扫描不同类型的队列, 发送完一类的一个分组，再发送下一个类的一个分组，循环所有类
4.  Weighted Fair Queuing (WFQ):
    *   一般化的Round Robin
    *   在一段时间内，每个队列得到的服务时间是：$W_i/ (XIGMA(W_i)) \times t$，和权重成正比
    *   每个类在每一个循环中获得不同权重的服务量
# IP协议
*   路由协议 → 路径选择 → RIP, OSPF, BGP
*   IP 协议 → 地址约定 •数据报格式 •分组处理的约定
*   ICMP 协议 → 错误报告 •路由器信
## 格式
![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_J6gh6ERsiF.png)
## IP分片与重组
*   网络链路有MTU (最大传输单元) –链路层帧所携带的最大数据长度
    *   不同的链路类型
    *   不同的MTU
*   大的IP数据报在网络上被分片(“fragmented”)
    *   一个数据报被分割成若干个小的数据报
        *   相同的ID
        *   不同的偏移量
        *   最后一个分片标记为0
    *   “重组”只在最终的目标主机进行
    *   IP头部的信息被用于标识，排序相关分片
## IP编址
*   IP 地址: 32位标示，对主机或者路由器的接口编址
*   接口: 主机/路由器和物理链路的连接处
    *   路由器通常拥有多个接口
    *   主机也有可能有多个接口
    *   IP地址和每一个接口关联
*   一个IP地址和一个接口相关联
    ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_NnSMtNza0W.png)
### 子网
*   一个子网内的节点（主机或者路由器）它们的IP地址的高位部分相同，这些节点构成的网络的一部分叫做子网
*   无需路由器介入，子网内各主机可以在物理上相互直接到达（需要链路交换机）
*   IP地址:
    *   子网部分(高位bits)
    *   主机部分(地位bits)
### CIDR: Classless Inter Domain Routing
*   无类域间路由
*   子网部分可以在任意的位置
*   地址格式: a.b.c.d/x, 其中 x 是 地址中子网号的长度
*   可以灵活编址
![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_c1RVfHqZXw.png)
### 子网掩码(subnet mask)
*   32bits , 0 or 1 in each bit
    *   1: bit位置表示子网部分
    *   0:bit位置表示主机部分

### 获取IP地址
1.  系统管理员将地址配置在一个文件中
    *   Wintel: control → panel → network→tcp/ip → properties
    *   UNIX: /etc/rc.config
2.  DHCP: Dynamic Host Configuration Protocol:
    *   从服务器中动态获得一个IP地址
    *   plug-and-play
    *   允许主机在加入网络的时候，动态地从服务器那里获得IP地址：
        *   可以更新对主机在用IP地址的租用期-租期快到了
        *   重新启动时，允许重新使用以前用过的IP地址
        *   支持移动用户加入到该网络（短期在网）
        ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_B58KlaCHqR.png)
## 层次编址: 路由聚集
*   路由器每次只招当前地址的下一层子网
*   路由器可以多报自己拥有的子网，不影响路由
## NAT: Network Address Translation
*   多个端系统共享一个IP
*   动机: 本地网络只有一个有效IP地址:
    *   不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备--省钱
    *   可以在局域网改变设备的地址情况下而无须通知外界
    *   可以改变ISP（地址变化）而不需要改变内部的设备地址
    *   局域网内部的设备没有明确的地址，对外是不可见的--安全
*   实现
    *   外出数据包：替换源地址和端口号为NAT IP地址和新的端口号，目标IP和端口不变
    *   记住每个转换替换对（在NAT转换表中）
    *   进入数据包：替换目标IP地址和端口号，采用存储在NAT表中的mapping表项，用（源IP，端口）
    ![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_4gR1JUYO8B.png)
### NAT 穿越问题
*   客户端需要连接地址为 10.0.0.1
    *   服务器地址10.0.0.1 LAN本地地址 (客户端不能够使用其作为目标地址)
    *   网只有一个外部可见地址: 138.76.29.7
1.  方案1: 静态配置NAT：转发进来的对服务器特定端口连接请求
    *   e.g., (123.76.29.7, port 2500) 总是转发到10.0.0.1 port 25000
2.  方案2: Universal Plug and Play (UPnP) Internet Gateway Device (IGD) 协议. 允许NATted主机可以:
    *   获知网络的公共 IP地址(138.76.29.7)
    *   列举存在的端口映射
    *   增/删端口映射 (在租用时间内)
3.  方案 3: 中继 (used in Skype)
    *   NAT后面的服务器建立和中继的连接
    *   外部的客户端链接到中继
    *   中继在2个连接之间桥接
## IPv6
### 头部
*   Priority: 标示流中数据报的优先级
*   Flow Label: 标示数据报在一个“flow.”
*   Next header: 标示上层协议
![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_IVeiNod_BX.png)
### 变化
*   Checksum: 被移除掉，降低在每一段中的处理速度
*   Options: 允许，但是在头部之外, 被 “Next Header” 字段标示
*   ICMPv6: ICMP的新版本 → 附加了报文类型, e.g. “Packet Too Big” ·多播组管理功能
### IPv4 ←→ IPv6
*   隧道: 在IPv4路由器之间传输的IPv4数据报中携带IPv6数据报
*   即多封装一次
# 通用转发与SDN
## 数量众多、功能各异的中间盒
*   路由器的网络层功能：
    *   IP转发：对于到来的分组按照路由表决定如何转发，数据平面
    *   路由：决定路径，计算路由表；处在控制平面
*   还有其他种类繁多网络设备（中间盒）：
    *   交换机；防火墙；NAT；IDS；负载均衡设备
    *   未来：不断增加的需求和相应的网络设备
    *   需要不同的设备去实现不同的网络功能
        *   每台设备集成了控制平面和数据平面的功能
        *   控制平面分布式地实现了各种控制平面功能
        *   升级和部署网络设备非常困难
## 传统网络设备控制平面
*   传统方式都是通过分布式，每台设备的方法来实现数据平面和控制平面功能
    *   垂直集成：每台路由器或其他网络设备，包括：
        *   硬件、在私有的操作系统；
        *   互联网标准协议(IP, RIP, IS-IS, OSPF, BGP)的私有实现
        *   从上到下都由一个厂商提供（代价大、被设备上“绑架”
    *   每个设备都实现了数据平面和控制平面的事情 → 控制平面的功能是分布式实现的
    *   设备基本上只能（分布式升级困难）按照固定方式工作，控制逻辑固化。
*   问题
    *   昂贵、不便于创新的生态
    *   分布式、固化设备功能==网络设备种类繁多
## SDN:逻辑上集中的控制平面
*   一个不同的（通常是远程）控制器和CA交互，控制器决定分组转发的逻辑（可编程），CA所在设备执行逻辑。
![](https://raw.githubusercontent.com/xuekanhua/images/master/img/image_DbFKgRDuQt.png)
### 思路
*   网络设备数据平面和控制平面分离
*   数据平面-分组交换机
    *   将路由器、交换机和目前大多数网络设备的功能进一步抽象成：按照流表（由控制平面设置的控制逻辑）进行PDU（帧、分组）的动作（包括转发、丢弃、拷贝、泛洪、阻塞）
    *   统一化设备功能：SDN交换机（分组交换机），执行控制逻辑
*   控制平面-控制器+网络应用
    *   分离、集中
    *   计算和下发控制逻辑：流表
### 优势
*   水平集成控制平面的开放实现（而非私有实现），创造出好的产业生态，促进发展
*   集中式实现控制逻辑，网络管理容易：
*   基于流表的匹配+行动的工作方式允许“可编程的”分组交换机
### 架构
*   数据平面交换机
    *   基于南向API（例如OpenFlow），SDN控制器访问基于流的交换机
    *   也定义了和控制器的协议(e.g., OpenFlow)
*   SDN 控制器(网络OS):
    *   维护网络状态信息
    *   通过上面的北向API和网络控制应用交互
    *   通过下面的南向API和网络交换机交互
    *   逻辑上集中，但是在实现上通常由于性能、可扩展性、容错性以及鲁棒性采用分布式方法
*   网络控制应用:
    *   控制的大脑： 采用下层提供的服务（SDN控制器提供的API)，实现网络功能
    *   非绑定：可以被第三方提供，与控制器厂商以通常上不同，与分组交换机厂商也可以不同
### OpenFlow
*   流: 由分组（帧）头部字段所定义
*   通用转发: 简单的分组处理规则
    *   模式: 将分组头部字段和流表进行匹配
    *   行动：对于匹配上的分组，可以是丢弃、转发、修改、将匹配的分组发送给控制器
    *   优先权Priority: 几个模式匹配了，优先采用哪个，消除歧义
    *   计数器Counters: bytes 以及 packets